<!DOCTYPE html>
<html>
<head>
  <title>Urban Awareness</title>
  <meta name="viewport" charset="utf-8" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <link rel="stylesheet" href="urban/plugin/L.Control.Sidebar.css" />
  <script src="urban/plugin/L.Control.Sidebar.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet-easybutton@2/src/easy-button.css" />
<script src="https://cdn.jsdelivr.net/npm/leaflet-easybutton@2/src/easy-button.js"></script>
<link rel="stylesheet" href="urban/plugin/style.css" />
<link
  rel="stylesheet"
  href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.css"
/>
<link
  rel="stylesheet"
  href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.Default.css"
/>

<script src="https://unpkg.com/leaflet.markercluster/dist/leaflet.markercluster.js"></script>
<script src="urban/plugin/L.Control.MousePosition.js"></script>
<link rel="stylesheet" href="urban/plugin/L.Control.MousePosition.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" />

<link
href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css"
rel="stylesheet"
>
<script
  src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js">
</script>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">

<script src="https://unpkg.com/leaflet.heat/dist/leaflet-heat.js"></script>


<!-- Leaflet Routing Machine -->
<link
  rel="stylesheet"
  href="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.css"
/>

<script src="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.js"></script>

</head>

<body>


  <nav class="navbar navbar-expand-lg navbar-dark bg-dark px-4">

    <a class="navbar-brand text-white" href="#" onclick="location.reload();" title="Click to reload the dashboard" style="justify-content: center;display: flex;align-items: center; width: 100%; text-wrap: inherit;">
      <i class="fas fa-globe-africa me-2"></i>
      Urban Awareness
   
    </a>
    
  </nav>

<div id="map"></div>

<div id="side-bar" style="background-color: #f1f1f1; font-family:Inter,sans-serif; font-size:14px;">
  <a href="javascript:void(0)" class="closebtn" onclick="sidebarreturn()">&times;</a>
  <br>
  <div class="sidebar-content">
    <h3>üìä Urban Score</h3>
    <p>
    Measures access to nearby urban services using proximity-based spatial analysis.
    A diversity bonus is applied when multiple service categories are available.
    </p>

    <details open>
      <summary>ü©∫ Health</summary>
      <ul>
        <li>üíä Pharmacies (‚â§1 km): 15 pts</li>
        <li>ü©∫ Primary Care (‚â§1.5 km): 25 pts<br><small style="color:#555;">Medical offices, centers & dispensaries</small></li>
        <li>üß™ Laboratories (‚â§2 km): 10 pts</li>
        <li>ü©ª Imaging Centers (‚â§2 km): 10 pts</li>
        <li>üè® Clinics (‚â§3 km): 15 pts</li>
        <li>üè• Hospitals (‚â§5 km): 25 pts</li>
      </ul>
    </details>

    <details>
      <summary>üöì Security</summary>
      <ul>
        <li>üëÆ Police (‚â§2 km): 30 pts</li>
        <li>ü™ñ Garde nationale (‚â§3 km): 25 pts</li>
        <li>üöí Protection civile (‚â§4 km): 25 pts</li>
        <li>üõÉ Douane (‚â§5 km): 10 pts</li>
      </ul>
    </details>

    <details>
      <summary>üöå Transport</summary>
      <ul>
        <li>üöï Taxi stations (‚â§0.5 km): 10 pts</li>
        <li>üöå Bus stations (‚â§0.8 km): 15 pts</li>
        <li>üöá Metro stations (‚â§1 km): 20 pts</li>
        <li>üöê Louage stations (‚â§2 km): 15 pts</li>
        <li>üöÜ Train stations (‚â§3 km): 20 pts</li>
      </ul>
    </details>
    <hr>
 <h2>üë• Population Adjustment</h2>

  <p>
    To better reflect real urban conditions, the final score is adjusted using
    <b>population pressure</b>.
  </p>

  <p>
    Each clicked location is linked to its corresponding
    <b>Delegation</b>, from which an official population value is retrieved.
    This value is normalized to produce a <b>Population Pressure Score</b>
    between <b>0</b> (low pressure) and <b>1</b> (high pressure).
  </p>

  <p><b>Final score formula:</b></p>

  <pre style="background:#eee;padding:8px;border-radius:6px;font-size:13px">
Final Score = Accessibility Score √ó (0.7 + 0.3 √ó Population Pressure)
  </pre>

  <p style="font-size:13px;color:#555">
    ‚Ä¢ 70% of the score reflects access to urban services (POI proximity)<br>
    ‚Ä¢ 30% reflects population-induced urban pressure
  </p>


  <hr>
    <p><strong>Total Score Meaning:</strong></p>
 <ul>
  <li>‚â•130 ‚Üí Good access üü¢</li>
  <li>70‚Äì129 ‚Üí Moderate access üü†</li>
  <li> <70 ‚Üí Poor access üî¥</li>
</ul>

  </div>
</div>


  

  <script>

const map = L.map('map', {
  center: [36.48, 9.61],
  zoom: 8,
  zoomControl: false  // disable default top-left zoom
});

    const topoesri = L.tileLayer(
  "https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}",
  {
    attribution: 'Tiles ¬© Esri',
    maxZoom: 19
  }
).addTo(map);
// OpenStreetMap
const osm = L.tileLayer(
  'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
  {
    attribution: '¬© OpenStreetMap contributors',
    maxZoom: 19
  }
);

// Esri Satellite Imagery
const esriSat = L.tileLayer(
  'https://server.arcgisonline.com/ArcGIS/rest/services/' +
  'World_Imagery/MapServer/tile/{z}/{y}/{x}',
  {
    attribution: 'Tiles ¬© Esri',
    maxZoom: 19
  }
);


const allPOIs = [];


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////// ADD GEOJSON DATA /////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////

const healthIcon = L.icon({
  iconUrl: 'urban/icons/red-cross.png',   // your icon
  iconSize: [30, 30],
  iconAnchor: [15, 30],
  popupAnchor: [0, -25]
});
const clusterGrouphealth = L.markerClusterGroup({
  spiderfyOnMaxZoom: true,
  showCoverageOnHover: true,
  maxClusterRadius: 50
});
///
const securityIcon = L.icon({
  iconUrl: 'urban/icons/poisecurity.png',   // your icon
  iconSize: [30, 30],
  iconAnchor: [15, 30],
  popupAnchor: [0, -25]
});
const clusterGroupsecurity = L.markerClusterGroup({
  spiderfyOnMaxZoom: true,
  showCoverageOnHover: true,
  maxClusterRadius: 50
});
/////
const transportIcon = L.icon({
  iconUrl: 'urban/icons/transportation.png',   // your icon
  iconSize: [30, 30],
  iconAnchor: [15, 30],
  popupAnchor: [0, -25]
});
const clusterGrouptransport = L.markerClusterGroup({
  spiderfyOnMaxZoom: true,
  showCoverageOnHover: true,
  maxClusterRadius: 50
});
    // 3. Load your GeoJSON
   


fetch('urban/data/health.geojson')
  .then(res => res.json())
  .then(data => {

    const poihealth = L.geoJSON(data, {
      pointToLayer: function (feature, latlng) {
      //   return L.marker(latlng, { icon: healthIcon });
      // },
      const marker = L.marker(latlng, { icon: healthIcon });

allPOIs.push({
  layer: marker,
  latlng: latlng,
  category: 'health',
  properties: feature.properties
});

return marker;
},

      onEachFeature: function (feature, layer) {
        layer.bindPopup(`
          <b>Nom :</b> ${feature.properties.Name_POI_F || '‚Äî'}<br>
          <b>Description :</b> ${feature.properties.Valeur_POI || '‚Äî'}
        `);
      }
    });

    clusterGrouphealth.addLayer(poihealth);
    // map.addLayer(clusterGrouphealth);
  });
/////
fetch('urban/data/security.geojson')
  .then(res => res.json())
  .then(data => {

    const poisecurity = L.geoJSON(data, {
      pointToLayer: function (feature, latlng) {
      //   return L.marker(latlng, { icon: securityIcon });
      // },
      const marker = L.marker(latlng, { icon: securityIcon });

allPOIs.push({
  layer: marker,
  latlng: latlng,
  category: 'security',
  properties: feature.properties
});

return marker;
},

      onEachFeature: function (feature, layer) {
        layer.bindPopup(`
          <b>Nom :</b> ${feature.properties.Name_POI_F || '‚Äî'}<br>
          <b>Description :</b> ${feature.properties.Valeur_POI || '‚Äî'}
        `);
      }
    });

    clusterGroupsecurity.addLayer(poisecurity);
    // map.addLayer(clusterGroupsecurity);
  });
/////
fetch('urban/data/transport.geojson')
  .then(res => res.json())
  .then(data => {

    const poitransport = L.geoJSON(data, {
      pointToLayer: function (feature, latlng) {
      //   return L.marker(latlng, { icon: transportIcon });
      // },
      const marker = L.marker(latlng, { icon: transportIcon });

allPOIs.push({
  layer: marker,
  latlng: latlng,
  category: 'transport',
  properties: feature.properties
});

return marker;
},

      onEachFeature: function (feature, layer) {
        layer.bindPopup(`
          <b>Nom :</b> ${feature.properties.Name_POI_F || '‚Äî'}<br>
          <b>Description :</b> ${feature.properties.Valeur_POI || '‚Äî'}
        `);
      }
    });

    clusterGrouptransport.addLayer(poitransport);
    // map.addLayer(clusterGrouptransport);
  });




//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// BASE MAPS/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

const baseMaps = {
  "OpenStreetMap": osm,
  "Esri Satellite": esriSat,
  "Esri Topographie":topoesri
};



const overlayMaps = {
  "Health": clusterGrouphealth,
  "Security": clusterGroupsecurity,
  "Transportation": clusterGrouptransport
};



  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////// ADD EASY-BUTTONS /////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
L.control.zoom({
  position: 'topleft'
}).addTo(map);

function sidebarreturn() {
				ctlSidebar.toggle();
			}
			ctlSidebar = L.control.sidebar("side-bar").addTo(map);
			ctlEasybutton = L.easyButton("fa fa-bars", function () {
				ctlSidebar.toggle();
			})
				.setPosition("topleft")
				.addTo(map);

L.easyButton({
    position: 'topleft',       // top right corner
    states: [{
        stateName: 'go-to-page',
        icon: 'fa-refresh',  // font awesome icon
        title: 'Return to previous page',
        onClick: function(btn, map){
            window.location.href = './index.html'; // redirect
        }
    }]
}).addTo(map);

L.control.mousePosition({ position: "bottomleft", prefix: "Lat : Long" }).addTo(map);

L.control.layers(baseMaps, overlayMaps, {
  collapsed: true,
  position: 'bottomleft'
}).addTo(map);

function showToast(message) {
  const toast = L.control({ position: 'bottomright' });

  toast.onAdd = function () {
    const div = L.DomUtil.create('div', 'map-toast');
    div.innerHTML = message;
    // div.style.zIndex = '5000'
    return div;
  };

  toast.addTo(map);

  setTimeout(() => {
    map.removeControl(toast);
  }, 10000);
}
showToast('Click anywhere on the map')


map.locate({ setView: false, maxZoom: 16 });

// When location is found, fly to it
map.on('locationfound', function(e) {
    map.flyTo(e.latlng, 14); // Zoom 16, you can adjust
   
});

// If location is not found
map.on('locationerror', function(e) {
    showToast("Could not get your location.");
});
///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////// Logic////////////////////////////

function distanceMeters(a, b) {
  return map.distance(a, b);
}

const securityConfig = {
  police: {
    icon: "üëÆ",
    label: "Police",
    radius: 2000,
    values: ["Police"],
    score: 30
  },
  gendarmerie: {
    icon: "ü™ñ",
    label: "Garde nationale",
    radius: 3000,
    values: ["Garde nationale"],
    score: 25
  },
  civil: {
    icon: "üöí",
    label: "Protection civile",
    radius: 4000,
    values: ["Protection civile"],
    score: 25
  },
  customs: {
    icon: "üõÉ",
    label: "Douane",
    radius: 5000,
    values: ["Douane"],
    score: 10
  }
};
const transportConfig = {
  taxi: {
    icon: "üöï",
    label: "Taxi stations",
    radius: 500,
    values: ["Station taxi"],
    score: 10
  },
  bus: {
    icon: "üöå",
    label: "Bus stations",
    radius: 800,
    values: ["Station bus"],
    score: 15
  },
  metro: {
    icon: "üöá",
    label: "Metro stations",
    radius: 1000,
    values: ["Station metro"],
    score: 20
  },
  louage: {
    icon: "üöê",
    label: "Louage stations",
    radius: 2000,
    values: ["Station louage"],
    score: 15
  },
  rail: {
    icon: "üöÜ",
    label: "Train stations",
    radius: 3000,
    values: ["Gare"],
    score: 20
  }
};


const healthConfig = {
  pharmacy: {
    icon: "üíä",
    label: "Pharmacies",
    radius: 1000,
    values: ["Pharmacie"],
    score: 15
  },
  primary: {
    icon: "ü©∫",
    label: "Primary Care",
    radius: 1500,
    values: [
      "Cabinet m√©dical",
      "Centre m√©dical",
      "Dispensaire"
    ],
    score: 25
  },
  laboratory: {
    icon: "üß™",
    label: "Laboratories",
    radius: 2000,
    values: ["Laboratoire d‚Äôanalyses"],
    score: 10
  },
  imaging: {
    icon: "ü©ª",
    label: "Imaging Centers",
    radius: 2000,
    values: ["Imagerie m√©dicale"],
    score: 10
  },
  clinic: {
    icon: "üè®",
    label: "Clinics",
    radius: 3000,
    values: ["Clinique"],
    score: 15
  },
  hospital: {
    icon: "üè•",
    label: "Hospitals",
    radius: 5000,
    values: ["H√¥pital"],
    score: 25
  }
};

const serviceDescriptions = {
  "Primary Care":
    "Medical offices, centers, and dispensaries."
};
let usedPOIs = [];

function analyzeHealth(latlng) {
  let totalScore = 0;
  let breakdown = [];
  let servicesFound = 0;
  let usedPOIs = []; // ‚úÖ NEW

  for (const key in healthConfig) {
    const cfg = healthConfig[key];

    const found = allPOIs.filter(poi => {
      if (!cfg.values.includes(poi.properties.Valeur_POI)) return false;
      return map.distance(latlng, poi.latlng) <= cfg.radius;
    });

    if (found.length > 0) {
      totalScore += cfg.score;
      servicesFound++;
    }

    usedPOIs.push(...found); // ‚úÖ NEW

    breakdown.push({
      icon: cfg.icon,
      label: cfg.label,
      count: found.length,
      radius: cfg.radius
    });
  }

  // diversity bonus
  if (servicesFound >= 4) {
    totalScore += 10;
  }

  return {
    totalScore,
    breakdown,
    usedPOIs // ‚úÖ NEW
  };
}

function analyzeSecurity(latlng) {
  let totalScore = 0;
  let breakdown = [];
  let servicesFound = 0;
  let usedPOIs = [];

  for (const key in securityConfig) {
    const cfg = securityConfig[key];

    const found = allPOIs.filter(poi => {
      if (poi.category !== 'security') return false;
      if (!cfg.values.includes(poi.properties.Valeur_POI)) return false;
      return map.distance(latlng, poi.latlng) <= cfg.radius;
    });

    if (found.length > 0) {
      totalScore += cfg.score;
      servicesFound++;
    }

    usedPOIs.push(...found);

    breakdown.push({
      icon: cfg.icon,
      label: cfg.label,
      count: found.length,
      radius: cfg.radius
    });
  }

  if (servicesFound >= 3) {
    totalScore += 10;
  }

  return { totalScore, breakdown, usedPOIs };
}
function analyzeTransport(latlng) {
  let totalScore = 0;
  let breakdown = [];
  let servicesFound = 0;
  let usedPOIs = [];

  for (const key in transportConfig) {
    const cfg = transportConfig[key];

    const found = allPOIs.filter(poi => {
      if (poi.category !== 'transport') return false;
      if (!cfg.values.includes(poi.properties.Valeur_POI)) return false;
      return map.distance(latlng, poi.latlng) <= cfg.radius;
    });

    if (found.length > 0) {
      totalScore += cfg.score;
      servicesFound++;
    }

    usedPOIs.push(...found);

    breakdown.push({
      icon: cfg.icon,
      label: cfg.label,
      count: found.length,
      radius: cfg.radius
    });
  }

  if (servicesFound >= 3) {
    totalScore += 10;
  }

  return { totalScore, breakdown, usedPOIs };
}


function interpretScore(score) {
  if (score >= 70) return { label: "GOOD", color: "green", icon: "üü¢" };
  if (score >= 40) return { label: "MODERATE", color: "orange", icon: "üü†" };
  return { label: "POOR", color: "red", icon: "üî¥" };
}

// function interpretTotalScore(score) {
//   if (score >= 160) return { label: "GOOD", color: "green", icon: "üü¢" };
//   if (score >= 90) return { label: "MODERATE", color: "orange", icon: "üü†" };
//   return { label: "POOR", color: "red", icon: "üî¥" };
// }
function interpretTotalScore(score) {
  if (score >= 130) return { label: "GOOD", color: "green", icon: "üü¢" };
  if (score >= 70)  return { label: "MODERATE", color: "orange", icon: "üü†" };
  return { label: "POOR", color: "red", icon: "üî¥" };
}

// -------------------- Floating Score Badge --------------------
const scoreBadge = L.control({ position: 'topright' });

scoreBadge.onAdd = function () {
  const div = L.DomUtil.create('div', 'score-badge');
  div.style.cssText = `
    background: rgba(0,0,0,0.7);
    color: #fff;
    padding: 6px 10px;
    border-radius: 8px;
    font-family: Inter,sans-serif;
    font-size: 14px;
    font-weight: 600;
    text-align: center;
  `;
  div.innerHTML = 'Area Score: ‚Äì';
  return div;
};
scoreBadge.addTo(map);


function updateGlobalBadge(score) {
  const status = interpretTotalScore(score);
  const div = document.querySelector('.score-badge');
  div.innerHTML = `
    Total Score: ${score}<br>
    ${status.icon} ${status.label}
  `;
}

// -------------------- Popup Builder --------------------

function renderDomainSection(title, icon, result, open = false) {

const status = interpretScore(result.totalScore);

let html = `
  <details ${open ? "open" : ""} style="margin-top:6px">
    <summary style="
      cursor:pointer;
      font-weight:600;
      outline:none;
    ">
      ${icon} ${title}
      <span style="color:${status.color}; margin-left:6px">
        ${status.icon} ${status.label}
      </span>
      <small>(${result.totalScore})</small>
    </summary>

    <ul style="padding-left:18px; margin:6px 0;">
`;

result.breakdown.forEach(item => {
  if (item.count > 0) {
    html += `
      <li>
        ${item.icon} ${item.label}:
        <b>${item.count}</b>
        <small>(‚â§${item.radius / 1000} km)</small>
        ${
          item.label === "Primary Care"
            ? `<br><small style="color:#555">
                 Medical offices, centers & dispensaries
               </small>`
            : ""
        }
      </li>
    `;
  }
});

if (result.breakdown.filter(b => b.count > 0).length >= 4) {
  html += `<li>üéÅ Diversity bonus: +10</li>`;
}

html += `
    </ul>
  </details>
`;

return html;
}


function buildPopup(health, security, transport,nearestDistances,population) {

let totalScore =
  health.totalScore +
  security.totalScore +
  transport.totalScore;
if (population) {
  const factor = 0.7 + 0.3 * population.pressureScore;
  totalScore = Math.round(totalScore * factor);
}
  updateGlobalBadge(totalScore);

let html = `
  <div style="font-family:Inter,sans-serif; font-size:14px; line-height:1.4">
    <b>üìç Area Overview</b><br>
`;

html += renderDomainSection("Health", "ü©∫", health); // open by default
html += renderDomainSection("Security", "üöì", security);
html += renderDomainSection("Transport", "üöå", transport,true);

html += `
    <hr style="margin:6px 0">
    <small style="color:#555">
      Proximity-based spatial analysis Scores.
    </small>
  </div>
`;
if (nearestDistances.length) {
  html += `
    <details style="margin-top:6px">
      <summary style="
        cursor:pointer;
        font-weight:600;
        outline:none;
      ">
        üìè Nearest key services
      </summary>

      <ul style="padding-left:18px; margin:6px 0;">
  `;

  // nearestDistances.forEach(d => {
  //   html += `
  //     <li>
  //       ${d.label}:
  //       <b>${(d.distance / 1000).toFixed(1)} km</b>
  //     </li>
  //   `;
  // });
  nearestDistances.forEach(d => {
  const color = valeurPOIColors[d.value] || '#333';
  // html += `
  //   <li>
  //     <span style="display:inline-block;width:12px;height:12px;background:${color};margin-right:6px;border-radius:2px;"></span>
  //     ${d.label}: <b>${(d.distance / 1000).toFixed(1)} km</b>
  //   </li>
  // `;
  html += `
  <li style="display:flex;align-items:center;justify-content:space-between;gap:8px;">
  <div>
    <span style="display:inline-block;width:12px;height:12px;background:${color};margin-right:6px;border-radius:2px;"></span>
    ${d.label}: <b>${(d.distance / 1000).toFixed(1)} km</b>
  </div>

  <button
    onclick="routeToPOI(L.latLng(${d.lat}, ${d.lng}))"
    style="
      border:none;
      background:#0d6efd;
      color:white;
      padding:1px 6px;
      margin-bottom:2px;
      font-size:12px;
      border-radius:6px;
      cursor:pointer;
    ">
        <i class="fas fa-route"></i>

  </button>
</li>

  `;
});


  html += `
      </ul>
    </details>
  `;
}

if (population) {
  html += `
    <details style="margin-top:6px">
      <summary style="cursor:pointer;font-weight:600">
        üë• Population context
      </summary>

      <ul style="padding-left:18px; margin:6px 0;">
        <li><b>Delegation:</b> ${population.governorate}</li>
        <li><b>Population:</b> ${population.population.toLocaleString()}</li>
        <li><b>Pressure level:</b> ${population.level}</li>
      </ul>
    </details>
  `;
}

return html;
}

// -------------------- Click Event with Highlights --------------------
let clickMarker = null;
let highlightLayer = L.layerGroup().addTo(map);


// map.on("click", async function(e) {
//   lastClickLatLng = e.latlng;

//   if (routingControl) {
//     map.removeControl(routingControl);
//     routingControl = null;
//   }
//   if (clickMarker) map.removeLayer(clickMarker);

//   clickMarker = L.circleMarker(e.latlng, {
//     radius: 6,
//     color: "#000",
//     fillColor: "#fff",
//     fillOpacity: 1
//   }).addTo(map);

//   const health = analyzeHealth(e.latlng);
//   const security = analyzeSecurity(e.latlng);
//   const transport = analyzeTransport(e.latlng);
//   const nearestDistances = runNearestAnalysis(e.latlng);
//   const population = analyzePopulation(e.latlng);

//   // --- OPEN POPUP IMMEDIATELY ---
//   const popup = L.popup({ maxWidth: 400 })
//     .setLatLng(e.latlng)
//     .setContent(buildPopup(health, security, transport, nearestDistances, population) +
//                 `<hr><b>üß† AI Area Analysis:</b><br><i>Loading...</i>`)
//     .openOn(map);

//   // --- FETCH AI RESPONSE ASYNC ---
//   try {
//     const aiText = await getAIAreaAnalysis(e.latlng.lat, e.latlng.lng);

//     // Update popup content when AI response arrives
//     popup.setContent(buildPopup(health, security, transport, nearestDistances, population) +
//                      `<hr><b>üß† AI Area Analysis:</b><br>${aiText}`);
//   } catch (err) {
//     popup.setContent(buildPopup(health, security, transport, nearestDistances, population) +
//                      `<hr><b>üß† AI Area Analysis:</b><br><i>Error loading AI response</i>`);
//     console.error("AI error:", err);
//   }

//   // highlightPOIs([...health.usedPOIs, ...security.usedPOIs, ...transport.usedPOIs]);
// });
map.on("click", function(e) {
  lastClickLatLng = e.latlng;

  if (routingControl) {
    map.removeControl(routingControl);
    routingControl = null;
  }
  if (clickMarker) map.removeLayer(clickMarker);

  clickMarker = L.circleMarker(e.latlng, {
    radius: 6,
    color: "#000",
    fillColor: "#fff",
    fillOpacity: 1
  }).addTo(map);

  const health = analyzeHealth(e.latlng);
  const security = analyzeSecurity(e.latlng);
  const transport = analyzeTransport(e.latlng);
  const nearestDistances = runNearestAnalysis(e.latlng);
  const population = analyzePopulation(e.latlng);

  let totalScore =
  health.totalScore +
  security.totalScore +
  transport.totalScore;
if (population) {
  const factor = 0.7 + 0.3 * population.pressureScore;
  totalScore = Math.round(totalScore * factor);
}

const areaData = {
  health: {
    totalScore: health.totalScore,
    breakdown: health.breakdown
  },
  security: {
    totalScore: security.totalScore,
    breakdown: security.breakdown
  },
  transport: {
    totalScore: transport.totalScore,
    breakdown: transport.breakdown
  },
  nearest: nearestDistances,
  population: population || null,
  totalScore: totalScore // the computed final score
};
// console.log(areaData)
  const popup = L.popup({ maxWidth: 400 })
    .setLatLng(e.latlng)
    .setContent(buildPopupWithAIButton(health, security, transport, nearestDistances, population))
    .openOn(map);
//  e.latlng.lat, e.latlng.lng
  // Attach click listener for AI button after popup is opened
  setTimeout(() => {
    const btn = popup.getElement().querySelector(".ai-trigger-btn");
    const resultDiv = popup.getElement().querySelector(".ai-result");

    if (!btn) return;

    btn.addEventListener("click", async () => {
      btn.disabled = true;
      btn.innerText = "Loading...";
      try {
        const aiText = await getAIAreaAnalysis(areaData);
        resultDiv.innerHTML = `<i>${aiText}</i>`;
      } catch (err) {
        resultDiv.innerHTML = `<i>Error loading AI response</i>`;
        console.error(err);
      }
    });
  }, 50); // slight delay to ensure DOM exists
});

function buildPopupWithAIButton(health, security, transport, nearestDistances, population) {
  let html = buildPopup(health, security, transport, nearestDistances, population);

  // Add AI button with a container for result
  html += `
    <hr>
    <b>üß† AI Area Interpretation:</b>
    <div class="ai-result" style="margin-top:4px; font-style:italic; color:#555;">
      <button class="ai-trigger-btn" style="
        border:none;
        background:#0d6efd;
        color:white;
        padding:4px 8px;
        border-radius:6px;
        cursor:pointer;
      ">
        Ask AI about this area
      </button>
    </div>
  `;

  return html;
}

function highlightPOIs(pois) {
  highlightLayer.clearLayers();

  pois.forEach(poi => {
    const highlightMarker = L.circleMarker(poi.latlng, {
      radius: 6,
      color: '#ff0000',
      weight: 2,
      fillColor: '#ff0000',
      fillOpacity: 0.3
    });
    highlightLayer.addLayer(highlightMarker);
  });

  // Auto-remove after 6 seconds
  setTimeout(() => {
    highlightLayer.clearLayers();
  }, 6000);
}




//////////////////////////////////////////////////////// osm/////////////////////////////

///////////// osmsearch////////
const osmSearchContainer = L.DomUtil.create('div', 'osm-search-container');

osmSearchContainer.innerHTML = `
  <div id="osm-search-box" style="display:none; width: 200px;">
    <input
      id="osm-search-input"
      type="text"
      class="form-control form-control-sm"
      placeholder="Search place OSM(Tunisia)"
      autocomplete="off"
    >
    <div id="osm-results" class="list-group mt-1"></div>
  </div>
`;

const osmSearchControl = L.control({ position: 'topright' });
osmSearchControl.onAdd = function () {
  // Prevent clicks on search container from propagating to map
  L.DomEvent.disableClickPropagation(osmSearchContainer);
  L.DomEvent.disableScrollPropagation(osmSearchContainer);
  return osmSearchContainer;
};
osmSearchControl.addTo(map);

const searchBox = document.getElementById('osm-search-box');
const osmInput = document.getElementById('osm-search-input');
const osmResults = document.getElementById('osm-results');

// EasyButton for search
const searchButton = L.easyButton('fa-magnifying-glass', function(btn, map) {
  btn.button.style.display = 'none'; // hide button
  searchBox.style.display = 'block'; // show search box
  osmInput.focus();
}, 'Search place').setPosition("topright").addTo(map);

// Collapse search box and show button
function collapseSearch() {
  searchBox.style.display = 'none';
  osmResults.innerHTML = '';
  searchButton.button.style.display = 'block';
}

// Collapse when clicking on map
map.on('click', collapseSearch);

let osmMarker = null;
let osmMarkerTimeout = null;
let osmSearchTimer = null;

// Search logic
osmInput.addEventListener('input', function () {
  const query = this.value.trim();
  osmResults.innerHTML = '';

  if (query.length < 3) return;

  clearTimeout(osmSearchTimer);

  osmSearchTimer = setTimeout(() => {
    const url =
      `https://nominatim.openstreetmap.org/search?` +
      `format=json&countrycodes=tn&addressdetails=1&limit=5&q=${encodeURIComponent(query)}`;

    fetch(url, {
      headers: { 'Accept': 'application/json', 'User-Agent': 'UrbanAnalysisGIS/1.0' }
    })
    .then(res => res.json())
    .then(data => {
      osmResults.innerHTML = '';
      if (!data.length) return;

      data.forEach(place => {
        const item = document.createElement('button');
        item.className = 'list-group-item list-group-item-action';
        item.style.fontSize = '12px';
        item.innerHTML = `<strong>${place.name || place.display_name.split(',')[0]}</strong><br>
                          <small class="text-muted">${place.display_name}</small>`;
        item.onclick = () => zoomToOSMPlace(place);
        osmResults.appendChild(item);
      });
    });
  }, 300);
});

function zoomToOSMPlace(place) {
  const lat = parseFloat(place.lat);
  const lon = parseFloat(place.lon);

  if (osmMarker) map.removeLayer(osmMarker);
  if (osmMarkerTimeout) clearTimeout(osmMarkerTimeout);

  osmMarker = L.marker([lat, lon])
    .addTo(map)
    .bindPopup(`<b>${place.display_name}</b>`)
    .openPopup();

  map.setView([lat, lon], 15);

  osmMarkerTimeout = setTimeout(() => {
    if (osmMarker) map.removeLayer(osmMarker);
    osmMarker = null;
  }, 5000);

  collapseSearch();
}


///////////////////////////////// heat//////////////////////////////////////
let heatmapLayer = null;

const heatmapControl = L.control({ position: 'bottomright' });

heatmapControl.onAdd = function () {
  const div = L.DomUtil.create('div', 'heatmap-control');
  div.innerHTML = `
    <label><b>Heatmap category</b></label>
    <select id="heatmapSelect" class="form-select form-select-sm">
      <option value="">-- None --</option>
    <option value="H√¥pital">üè• Hospital</option>
    <option value="Clinique">üè® Clinic</option>   
    <option value="Station metro">üöá Metro </option>
    <option value="Gare">üöÜ Train </option>
    </select>
  `;
  L.DomEvent.disableClickPropagation(div);
  return div;
};

heatmapControl.addTo(map);
////////////////////////////////

document.getElementById('heatmapSelect').addEventListener('change', function () {
  const category = this.value;

  // remove old heatmap if exists
  if (heatmapLayer) {
    map.removeLayer(heatmapLayer);
    heatmapLayer = null;
  }

  if (!category) return; // None selected

  // get latlngs of POIs in this category
  const points = allPOIs
    .filter(poi => poi.properties.Valeur_POI === category)
    .map(poi => [poi.latlng.lat, poi.latlng.lng, 15]); // last value = intensity

  if (points.length === 0) return;

  heatmapLayer = L.heatLayer(points, {
  radius: map.getZoom() * 2 + 10, // increases radius when zooming out
  blur: 20,
  maxZoom: 17,
  gradient: {
    0.2: '#2a9d8f',
    0.4: '#f4a261',
    0.6: '#e76f51',
    0.8: '#e63946',
    1.0: '#d62828'
  }
}).addTo(map);

});

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////// NEAREST /////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Layer for nearest analysis (separate from highlightLayer)
const nearestLayer = L.layerGroup().addTo(map);

// Style per domain
const nearestStyles = {
  health: { color: '#e63946' },
  security: { color: '#457b9d' },
  transport: { color: '#2a9d8f' }
};

const nearestServices = [
  // Health
  { value: "H√¥pital", category: "health", label: "Hospital" },
  { value: "Clinique", category: "health", label: "Clinic" },

  // Security
  { value: "Police", category: "security", label: "Police" },
  { value: "Protection civile", category: "security", label: "Fire station" },
  { value: "Garde nationale", category: "security", label: "Gendarmerie" },

  // Transport
  { value: "Gare", category: "transport", label: "Train station" },
  { value: "Station metro", category: "transport", label: "Metro station" }
];
const valeurPOIColors = {
  "Police": "#1f77b4",          // blue
  "Garde nationale": "#ff7f0e",  // orange
  "Protection civile": "#2ca02c",// green
  "Douane": "#d62728",           // red
  "Station taxi": "#9467bd",     // purple
  "Station bus": "#8c564b",      // brown
  "Station metro": "#e377c2",    // pink
  "Station louage": "#7f7f7f",   // gray
  "Gare": "#bcbd22",             // olive
  "Pharmacie": "#17becf",        // cyan
  "Cabinet m√©dical": "#aec7e8",  // light blue
  "Centre m√©dical": "#ffbb78",
  "Dispensaire": "#98df8a",
  "Laboratoire d‚Äôanalyses": "#ff9896",
  "Imagerie m√©dicale": "#c5b0d5",
  "Clinique": "#c49c94",
  "H√¥pital": "#f7b6d2"
};


function runNearestAnalysis(clickLatLng) {
  nearestLayer.clearLayers();

  const distances = [];

  nearestServices.forEach(service => {
    let nearest = null;
    let minDistance = Infinity;

    allPOIs.forEach(poi => {
      if (poi.category !== service.category) return;
      if (poi.properties.Valeur_POI !== service.value) return;

      const d = map.distance(clickLatLng, poi.latlng);
      if (d < minDistance) {
        minDistance = d;
        nearest = poi;
      }
    });

    if (!nearest) return;

    const style = nearestStyles[service.category] || { color: '#333' };

    // draw dashed line
    // L.polyline(
    //   [clickLatLng, nearest.latlng],
    //   {
    //     color: style.color,
    //     weight: 2,
    //     opacity: 0.7,
    //     dashArray: '5,5'
    //   }
    // ).addTo(nearestLayer);

    // // highlight nearest POI
    // L.circleMarker(nearest.latlng, {
    //   radius: 7,
    //   color: style.color,
    //   weight: 2,
    //   fillOpacity: 0.9
    // }).addTo(nearestLayer);

 L.polyline(
  [clickLatLng, nearest.latlng],
  {
    color: valeurPOIColors[nearest.properties.Valeur_POI] || '#333',
    weight: 3,
    dashArray: '5,5'
  }
).addTo(nearestLayer);

// highlight nearest POI
L.circleMarker(nearest.latlng, {
  radius: 7,
  color: valeurPOIColors[nearest.properties.Valeur_POI] || '#333',
  fillOpacity: 0.9
}).addTo(nearestLayer);

    distances.push({
      value: service.value,
      label: service.label,
      distance: minDistance,
      lat: nearest.latlng.lat,   // ‚úÖ add this
      lng: nearest.latlng.lng    // ‚úÖ add this
    });
  });

  // auto clear after 6 seconds
  // setTimeout(() => nearestLayer.clearLayers(), 6000);

  return distances;
}

////////////////////////////Population Analysis///////////////////

// ================= POPULATION LAYER =================
let govLayer = null;
let govFeatures = [];
let popMin = Infinity;
let popMax = -Infinity;

fetch('urban/data/deleg.geojson')
  .then(res => res.json())
  .then(data => {

    govLayer = L.geoJSON(data, {
      style: {
        color: '#555',
        weight: 2,
        fillOpacity: 0
      }
    });

    govFeatures = data.features;

    // compute min / max population once
    govFeatures.forEach(f => {
      const pop = Number(f.properties.population);
      if (!isNaN(pop)) {
        popMin = Math.min(popMin, pop);
        popMax = Math.max(popMax, pop);
      }
    });

    console.log('Population range:', popMin, popMax);
  });
///////

// ================= POPULATION ANALYSIS =================
function analyzePopulation(latlng) {
  if (!govFeatures.length) return null;

  let foundGov = null;

  govFeatures.forEach(feature => {
    const layer = L.geoJSON(feature);
    if (layer.getBounds().contains(latlng)) {
      foundGov = feature;
    }
  });

  if (!foundGov) return null;

  const population = Number(foundGov.properties.population);
  const name = foundGov.properties.NAME_1 || 'Unknown';

  // normalize population
  const norm =
    popMax === popMin
      ? 0
      : (population - popMin) / (popMax - popMin);

  // pressure score (inverse logic)
  const pressureScore = 1 - norm;

  // qualitative label
  let level = 'LOW üü¢';
  if (norm > 0.66) level = 'HIGH üî¥';
  else if (norm > 0.33) level = 'MODERATE üü†';

  return {
    governorate: name,
    population: population,
    norm,
    pressureScore,
    level
  };
}
//////////////////////////////////////////////////////////////
//////////////////////////////// routing leaflet ////////////////////
/////////////////////////////////////////////////////////////////////


let routingControl = null;
let lastClickLatLng = null;

function routeToPOI(targetLatLng) {
  if (!lastClickLatLng) return;
  if (!L.Routing) {
    showToast("‚ö†Ô∏è Routing service not available");
    return;
  }

  try{
  // remove existing route
  if (routingControl) {
    map.removeControl(routingControl);
    routingControl = null;
  }

  routingControl = L.Routing.control({
    waypoints: [
      lastClickLatLng,
      targetLatLng
    ],
    addWaypoints: false,
    draggableWaypoints: false,
    fitSelectedRoutes: true,
    show: false,                // üö´ no itinerary panel
    routeWhileDragging: false,
    createMarker: () => null,   // üö´ no markers
    lineOptions: {
      styles: [{
        color: '#0d6efd',
        weight: 5,
        opacity: 0.85
      }]
    }
  }).on('routingerror', function () {
      showToast("‚ùå Route not available");
      if (routingControl) {
        map.removeControl(routingControl);
        routingControl = null;
      }
    }).addTo(map);
  } catch (err) {
    console.error(err);
    showToast("‚ùå Route not available");
  }
}
//////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////: AI integration::::::::::::::::::::::::::::::::::::::::::
/////////////////////////////////////////////////////////////////////////////////////////
// async function getAIAreaAnalysis(lat, lng) {
//   const promptText = `
// You are an urban intelligence assistant.
// Provide a short, approximate safety assessment for this location:
// Latitude: ${lat}, Longitude: ${lng}.
// Do NOT give exact crime rates.
// Use urban context and nearby services.
// Return ONE short sentence.
// `;

async function getAIAreaAnalysis(areaData) {
  const cerebrasApiKey = "csk-8p4m5hwej34dnpjd2tm23frndcw33y3vd9f4yvw9fn6cefyd"; // your Cerebras key
  const deepAiApiKey = "3d1eb2de-5575-42af-9b56-cd043717fc1a";        // your DeepAI key

  const promptText = `
You are an expert urban planning consultant and strategist.
Based on the area analysis below, suggest investments, future needs, and actionable recommendations with possible costs in tunisian dinars.
Your response must be exactly one short sentences‚Äîconcise and impactful.
Area analysis:
${JSON.stringify(areaData, null, 2)}
`;

  /* =========================
     1Ô∏è‚É£ USE CEREBRAS
  ==========================*/
  try {
    const response = await fetch(
      "https://api.cerebras.ai/v1/chat/completions",
      {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${cerebrasApiKey}`,
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          model: "llama-3.3-70b",   // or another Cerebras model you prefer
          messages: [
            { role: "system", content: "You are an expert urban planning assistant." },
            { role: "user", content: promptText }
          ],
          temperature: 0.7,
          max_tokens: 150
        })
      }
    );

    if (response.ok) {
      const data = await response.json();
      const textOutput = data?.choices?.[0]?.message?.content?.trim();
      if (textOutput) return textOutput;
    }

    console.warn("Cerebras returned bad response");
  } catch (err) {
    console.error("Cerebras failed:", err);
  }

  /* =========================
     2Ô∏è‚É£ FALLBACK: DEEPAI
  ==========================*/
  try {
    const response = await fetch(
      "https://api.deepai.org/api/text-generator",
      {
        method: "POST",
        headers: {
          "Api-Key": deepAiApiKey,
          "Content-Type": "application/x-www-form-urlencoded"
        },
        body: new URLSearchParams({ text: promptText })
      }
    );

    if (response.ok) {
      const data = await response.json();
      const textOutput = data?.output?.trim();
      if (textOutput) return textOutput;
    }

    console.warn("DeepAI returned bad response");
  } catch (err) {
    console.error("DeepAI failed:", err);
  }

  /* =========================
     3Ô∏è‚É£ FINAL FALLBACK
  ==========================*/
  showToast("AI insight temporarily unavailable");
  return "AI insight temporarily unavailable";
}

  </script>
</body>
</html>
